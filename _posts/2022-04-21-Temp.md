---
layout: post
mathjax: true
title: The KGZ/Kate Polynomial Commitment Scheme
category: uc
---

{% include mathjax.html %}

A commitment scheme is a cryptographic primitive that allows one to commit to a chosen value (or chosen statement) while keeping it hidden to others, with the ability to reveal the committed value later. Commitment schemes are designed so that a party cannot change the value or statement after they have committed to it: that is, commitment schemes are binding.

Polynomials are frequently used in cryptography because they can be used to encode a lot of information. A Polynomial Commitment Scheme (PCS) allows a committer to commit to a polynomial with a commitment string that can be used by a verifier to confirm claimed evaluations of the committed polynomial. We will look at one such PCS called KGZ (Kate, Zaverucha, Goldberg) Commitment. It's also referred to as the Kate Commitment scheme.

## KGZ Commmitment Scheme   

Let $F(x)$ be the Polynomial which needs to be committed. $F(x) \in \mathbb F_p$ is a polynomial of degree $d$ or less.  

**Trusted Setup** 

$\mathbb G$ is an elliptic curve group with a generator $G$. The **d-Strong Diffie Hellman** assumption holds in group $\mathbb G$. The first stage of the commitment scheme is a trusted setup. During the trusted setup, a random value $a \in \mathbb F_p$ is sampled. Then the following tuple of size $d+1$ known as the Reference String is generated - $\lbrace G, aG,a^2G, a^3G, ..., a^dG \rbrace$. After this the random value $a$ is deleted such that it's not known to anyone after the Reference String has been generated.


**Commitment**

Let's denote the commitment of the polynomial $F(x)$ at $x=a$ as $C_{F_a}$ where 

$C_{F_a} = F(a).G$ where F(a) is the polynomial evaluated at $x=a$.

Though $a$ has been deleted, the verifier can stil calculate the commitment using the Reference String.

Let $F(x) = f_0 + f_1x + f_2x^2 + ... + f_dx^d$ 

So $C_{F_a} = F(a).G = (f_0 + f_1a + f_2a^2 + ... + f_da^d).G$ (This is the evaluation of $F(x)$ at $x = a$ scalar multiplied the generator with the evaluation)

$C_{F_a} = f_0.G + f_1a.G + f_2a^2.G + ... + f_da^d.G$ 

Though the prover doesn't know $a$, she knows $\lbrace G, aG,a^2G, a^3G, ..., a^dG \rbrace$ from the reference string & can evaluate $C_{F_a}$ & evaluate the commitment

Since $G$ is a generator of the Elliptic Curve group $\mathbb G$, the commitment is a point on the Elliptic Curve.

**Opening**

The verifier selects a random value $b \in \mathbb F_p$ & sends it to the prover. The prover has to evaluate the polynomial $F(x)$ at $x=b$. Let's say $F(x=b)$ evaluates to $c$. Unlike $a$ which is secret, $b$ is not a secret & hence the Prover can evaluate $F(x)$ at $b$ & provide the result $c$ to the verifier. The prover also has to provide a proof to the verifier that $F(b) = c$. 

The proof which the Prover provides to the verifier is the Commitment $C_Q$ of $Q(x)$. $Q(x)$ is defined as 

$Q(x) = \frac {F(x) - F(b)} {x-b} = \frac {F(x) - c} {x-b}$

If $Q(x)$ is indeed a polynomial, then the Commitment of $Q(x)$ will be 

$C_{Q_a} = Q(a).G$ (Note that this is the commitment of $Q(x)$ at $x=a$ & not at $x=b$)

As per Little Bezout’s Theorem, if $F(x)$ is a polynomial, then $F(x) - F(b)$ is perfectly divisible by $(x-b)$ i.e. the remainder is $0$. So $Q(x)$ above is a polynomial i.e. it won't have any variable in the denominator or any negative exponents. If $Q(x)$ is a polynomial, then the Prover can calculate the Commitment of $Q(x)$ using the Reference String & send it to the Verifier.

**Verifying** 

A commitment scheme or a proof system is said to be **complete** if anything which is true is provable. It is said to be **sound** if everything which is provable is true - i.e. anything which is false cannot be proven by the system.

The Verifier has $C_{F_a}$, $C_{Q_a}$ & $c$ & he needs to verify if $F(b) = c$

$Q(x) = \frac {F(x) - c} {x-b}$

So,

$(x-b).Q(x) = F(x) - c$

If you evaluate this at $a$, it becomes

$(a-b).Q(a) = F(a) - c$

If the verifier is able to verify that the above equality holds good, then he has verified the commitment (because of the Schwartz–Zippel lemma which is explained later).

Multiplying both sides by $G$, we get

$(a-b).Q(a).G = F(a).G - c.G$

Now, $C_{F_a} = Q(a).G$ & $C_{Q_a} = F(a).G$. So substituting, we get

$(a-b).C_{Q_a} = C_{F_a} - c.G$

So this is the equality the verifier has to verify to verify the commitment. He cannot do it directly because the value of $a$ has been deleted. 

So a Elliptic Curve Pairing group is used for the verification. The pairing denoted by the map 

$e:\space \mathbb G$ X $\mathbb G  \mapsto \mathbb G_T$

[**Note:** If you are not familiar with pairings, I have given a small introduction to one particular kind of pairing called Weil Pairing here - [Weil Pairing and the MOV attack on Elliptic Curve Cryptography](https://risencrypto.github.io/WeilMOV/). You can also take a look at [Vitalik Buterin's write up on Pairings](https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627)]

This is the equality to verify

$(a-b).C_{Q_a} \stackrel {?}{=} C_{F_a} - c.G$

Each input to a pairing needs to be an element of the Group. Any commitment is a scalar multiplication of the generator of the Group, so both $C_{F_a}$ & $C_{Q_a}$ are elements of $\mathbb G$. Since $C_{Q_a}$ is an element of the group multiplying it with the scalar $a-b$ also will result in an other element of the group. So $(a-b).C_{Q_a}$ is an element of $\mathbb G$. $C_{F_a}$ & $c.G$ are both elements of the group, so $C_{F_a} - c.G$$ is also an element of the group. So all the terms in the equality are group elements. So they can be inputs to the pairing map. 

By passing the sides of the equality as the first parameter to the map & pass $G$ as the 2nd param, we can turn the equality to be verified into

$e((a-b).C_{Q_a}, G) \stackrel {?}{=} e(C_{F_a} - c.G, G)$

This still doesn't help us because we don't know $a$.

However, bilinearity property of the pairing map means that 

$e(\alpha A,B) = e(A, \alpha B)$ where $\alpha$ is a scalar.

So we can rewrite it as 


$e(C_{Q_a}, (a-b).G) \stackrel {?}{=} e(C_{F_a} - c.G, G)$

Further simplifying

$e(C_{Q_a}, aG - bG) \stackrel {?}{=} e(C_{F_a} - c.G, G)$

Though we don't know $a$, we do know $aG$ from our Reference String. So now the verifier can verify whether the above equality is true or not. Thus this commitment scheme is **Complete**. If the commitment is true, then it's provable. 

Since the group $\mathbb G$  is a group where the **d-Strong Diffie Hellman** assumption holds, it can be shown that the probability of the Prover finding two tuples $<b, c, C_{Q_a}>$ & $<b', c', C_{Q'_a}> $ such that

$e(C_{Q_a}, aG - bG) = e(C_{Q'_a}, aG - b'G)$ is negligible. Thus the commitment scheme is **Sound**. If the commitment is not true, then it's not provable.

**Batch Mode**

KGZ commitments can also be opened & verified at multiple points using a single proof.

In the Opening, the verifier sampled a random value $b \in \mathbb F_p$ & the prover evaluated $F(b) = c$ & provided $c$ along with the proof to the verifier.

In batch mode, the verifier samples multiple random values $b_1, b_2, b_3, ..., b_t$ such that $t \lt d$ & sends it to the prover, the prover evaluates $f(b_1) = c_1, f(b_2) = c_2, ..., f(b_t) = c_t$ and provides proof of evaluation.

Let $P(x) = (x-b_1)(x-b_2)....(x-b_t)$

Since the degree of $F(x)$ is $d$ & $t \lt d$, we can divide $F(x)$ by $P(x)$. Let the Quotient of the division be $Q(x)$ & the remainder be $R(x)$ (Note that here we aren't saying that $F(x)$ is divisible by $Q(x)$, so we have remainder here). So,

$F(x) = P(x).Q(x) + R(x)$

$F(x) - R(x) = P(x).Q(x)$

Multiply both sides by the generator $G$

$F(x).G - R(x).G = P(x).Q(x).G$

Evaluate the above equation at $a$

$F(a).G - R(a).G = P(a).Q(a).G$.

Now, as per definition of a commitment,

$C_{F_a} = F(a).G$  

$C_{R_a} = R(a).G$

$C_{Q_a} = Q(a).G$

So,

$C_{F_a} - C_{R_a} = P(a).C_{Q_a}$

The verifier needs to evaluate the above to verify the proof. However, since $a$ is unknown, he cannot evaluate $P(a)$, so again we using pairings like before.

$C_{F_a}$ & $C_{R_a}$ are both elements of $\mathbb G$, so $C_{F_a} - C_{R_a}$ is also an element of $\mathbb G$

$C_{Q_a}$ is an element of $\mathbb G$ & $P(a)$ is a scalar. So $P(a).C_{Q_a}$ is also an element of $\mathbb G$.

So we can apply the pairing map to both sides

$e(C_{F_a} - C_{R_a}, G) = e(P(a).C_{Q_a}, G)$

However, bilinearity property of the pairing map means that 

$e(\alpha A,B) = e(A, \alpha B)$ where $\alpha$ is a scalar.

So, we can rewrite the Right Hand Side as 

$e(C_{F_a} - C_{R_a}, G) = e(C_{Q_a}, P(a).G)$

Since, $P(x) = (x-b_1)(x-b_2)....(x-b_t)$  

$P(a) = (a-b_1)(a-b_2)....(a-b_t)$

$e(C_{F_a} - C_{R_a}, G) = e(C_{Q_a}, (a-b_1)(a-b_2)....(a-b_t).G)$


$e(C_{F_a} - C_{R_a}, G) = e(C_{Q_a}, (aG-b_1G)(aG-b_2G)....(aG-b_tG))$

The prover has provided $b_1, b_2, ..., b_t$ to the verifier & also provided the commitments $C_{Q_a}, C_{R_a}$.  And though the verifier doesn't know $a$, he does know $aG$ from the reference string. So all the terms in this equation are known to the verifier & he can thus verify it.
