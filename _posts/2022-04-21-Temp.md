---
layout: post
mathjax: true
title: Cofactor clearing in composite order Elliptic Curves
category: uc

---

{% include mathjax.html %}

Many cryptographic protocols use elliptic curves of prime order. However there are composite order curves like the Edwards Curve, Montgomery Curves which easily provide faster group operations with complete addition laws which are not vulnerable to a timing attack. So many modern elliptic curve implentations use a composite order curve with a small co-factor. The order of these curves is  $h.p$ where $p$ is a prime & $h$ is a small cofactor usually $8$ or lesser. The composite order curve has a subgroup of prime order $p$ which is used for the implementations. Though these curves have a lot of advantages, there are also some disadvantages one of which we discuss below called as a small subgroup attack.

## Small Subgroup attack in non-prime order curves

The operations are usually implemented in the prime order subgroup of the full Curve. Let's take the example of Diffie Hellman to understand the small subgroup attack. Let's say our curve is of order $8p$ where $p$ is a prime & $8$ is the cofactor. Let $G$ be a generator of the prime order subgroup. Let $a$ & $b$ be Alice's & Bob's private keys respective. This is how a typical Diffie Hellman key exchange works.

$$
\text{Alice} \xrightarrow{\hspace{3cm} a G \hspace{3cm}} \text{Bob} \\
\text{Alice} \xleftarrow{\hspace{3cm} b G \hspace{3cm}} \text{Bob}
$$

Alice calculates $a.bG$, Bob calculates $b.aG$ and the shared secret is derived from $abG$ by both parties.

Now if Bob was a malicious player he can launch a small subgroup attack which can leak some information about Alice's private key. The protocol depends on operating in the prime order subgroup (i.e. the subgroup of order $p$). However the curve curve also contains other subgroups - one of which is of order $8$. The points of the subgroup of order $8$ are not in the prime order subgroup (other than the identity). Lets say $H$ is a **generator** of the subgroup of order $8$. Now, Bab instead of sending $bG$ to Alice sends $H$ to Alice. So Alice calculates $aH$ & derives the share secret using that. Alice then encrypts a message using the shared secret & sends it to Bob. Now if Alice's share secret had been derived from $abG$, then number of possible values $abG$ could have is $p$ which is a very large prime - for e.g. for $ed25519$, $p = 2^{252} + 27742317777372353535851937790883648493$ so brute forcing is not possible. However, since Bob has made Alice derive her shared secret from $aH$, it's much simpler. Since $H$ is a generator of subgroup of order $8$, $aH$ is a point of the subgroup of order $8$ because of closure in the subgroup. Now brute forcing the secret key is much simpler for Bob since it's now based on only one of $8$ points. Which of the $8$ points $aH$ depends $a \bmod 8$, so this leaks info about the lower 3 bits of $a$. 

To understand this better, let's take the example of a simple additive Group of order $8p$ where $p = 11$. This is the group $Z/{88Z}$. This has the elements {0, 1, 2, 4, .... 87$ (I am omitting the coset notation for simplicity)

This has multiple subgroups including the subgroup of order $11$ - $\lbrace 0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80 \brace}$. The cofactor subgroup of order $8$ is $\lbrace 0, 11, 22, 33, 44, 55, 66, 77 \rbace$. 

Let the generator chosen for the DH exchange be $8$. Now Bob instead of sending $b8$, can send a generator of the cofactor subgroup like $11$. So now Alice computes $11a$. Irrespective of what $a$ is chosen by Alice, $11a$ always is restricted to 8 different elements instead of $11$ different elements if Bob was a honest player. Alice then derives a secret key from $11a$ & encrypts a message & sends it to Bob. Bob can brute force the secret key by doing an exhaustive search through $8$ different elements instead of $11$ different elements - in this case, it's not much of a difference, but in the case of actual cryptographic curves, the reduction in search is huge -  from searching through a really large set of size $p$ to searching through just $8$ points. Once you know $aH$ you can get $a \bmod 8$ as

~~~
# writing it using sagemath functions
a mod 8 = mod(inverse_mod(Integer(mod(H,8), 8)) * mod(a*H, 88), 8)$ 
~~~

i.e. you can figure out the lower $3$ bits of $8$ 

There are also a couple of other similar attacks 

- Instead of sending $bG$, Bob can send $bG + H$ to Alice. So Alice now calculates $abG + aH$. Now since Bob knows $abG$, this again leaks $a \bmod 8$ which is the lower 3 bits of $a$.

- Instead of Bob launching the above attack, if Bob is a honest player but a man in the middle (Mallory) intercepts $bG$ sent by Bob & replaces it with $H$, then he can brute force the secret key generated by Alice ($aH$) because it can only be one of $8$ points.

The above attack is not limited to Diffie Hellman, but also applicable to many other Cryptographic protocols like signature validation etc. The small subgroup attack has very bad effects on some protocols like PAKE, MQV etc.


## Mitigation for the small subgroup attack - cofactor clearing

Scalar multipliying any point by the cofactor ($8$ in this case) projects the point on to the prime order subgroup, irrespective of which subgroup it was in originally. This can be easily done by both parties - i.e. when Alice receives $bG$ from Bob, instead of computing $abG$, she can compute $8abG$ & likewise Bob does the same when gets $aG$ from Alice. Now if Bob is a malicious player, then what is leaked is $8a \bmod 8$ instead of $a \bmod 8$. Since $8a \bmod 8$ is always 0, nothing of significance is leaked. Mutliplying by $8$ clears the lower $3$ bits.  

~~~
sage: L = [] # Initialize an empty lit
....: for i in range(88):  # Go through every element of the group
....:     out = mod(8*i, 88) # Clear cofactor by scalar multiplying by the cofactor
....:     if out not in L: # If the output is not already present in the list 
....:         L.append(out) # append it to the list
....: L # Output the list after cofactor clearning
....:

[0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80] # **Output** Any point in the full group when 
                         # scalar multipled by the cofactor maps to a prime order element
~~~

The above sage program takes every element from the full group & scalar multiplies 

## Torsion safe cofactor clearing

The method of cofactor clearing by scalar multiplying by the cofactor works fine for many protocols but isn't suitable everywhere. Let's look at why. 
A cyclic group $G_{mn}$ of order $mn$ where $m$ & $n$ are coprime is isomorphic to a product group $G_m \times G_n$. So our ellipic curve group $G_{8p}$ can be looked as $G_8 \times G_p$. The map for this isomorphism is

$\phi(a, b) = na + mb | a \in G_p, b \in G_8$

This means any point P on the full curve can be written as sum of 2 components i.e. the prime order component Q & a component T from the subgroup of order $8$ - i.e. the $8-torsion$ component such that $P = 8Q + pT$

Clearing the lower 3 bits of $P$ could change both the prime order component & also the l-torsion component. This may not be appropriate in some places (for e.g. heirarchical key derivation schemes). In these cases, we need a "torsion-safe" method of cofactor clearing.

To understand how Torsion safe clearing can be done, let's again use  the simple additive group we used earlier - i.e.  $Z/{88Z}$. For simplicity, I will omit the quotient group notation & refer to it as $Z_{88}$. 

$Z_{88} \cong Z_{11} \times Z_8$.

with

$\phi(a, b) = 8a + 11b | a \in Z_11, b \in Z_8$

For e.g. $18 = 8.16 + 11.22$  (mod 88)
For the element $18$, $16$ is prime-order component & $22$ is the 8-torsion component. We want to clear the 8-torsion component without disturbing the 

So to clear the cofactor, we need to multiply by a scalar $s$, 





